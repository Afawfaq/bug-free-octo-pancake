#!/usr/bin/env python3
"""
UPnP/SSDP Vulnerability Scanner
Based on research from:
- Security Flaws in Universal Plug and Play (Rapid7 2013)
- SSDP/UPnP exploitation research (CERT, CVE-2025-27484)
- Evil SSDP attack methodology

Detects:
- Buffer overflow vulnerabilities in libupnp
- Exposed UPnP services on WAN
- SSDP spoofing susceptibility
- Memory corruption risks
- Insecure service configurations
"""

import socket
import struct
import json
import re
from datetime import datetime
from typing import Dict, List, Optional, Tuple
import os


class UPnPVulnerabilityScanner:
    """Scanner for UPnP/SSDP security vulnerabilities."""
    
    def __init__(self, output_dir: str = '/output/iot'):
        self.output_dir = output_dir
        self.vulnerabilities = []
        self.devices_scanned = []
        
        # Known vulnerable libupnp versions
        self.vulnerable_versions = [
            r'libupnp/1\.6\.([0-9]|1[0-7])($|[^0-9])',  # < 1.6.18
            r'libupnp/1\.[0-5]\.',  # All 1.0-1.5 versions
        ]
        
        # Critical CVEs
        self.known_cves = {
            'CVE-2012-5958': 'Stack-based buffer overflow in libupnp',
            'CVE-2012-5959': 'Heap-based buffer overflow in libupnp',
            'CVE-2012-5960': 'Stack-based buffer overflow in SSDP',
            'CVE-2012-5961': 'Heap-based buffer overflow in SSDP',
            'CVE-2012-5962': 'Stack-based buffer overflow in HTTP',
            'CVE-2012-5963': 'Stack-based buffer overflow in miniserver',
            'CVE-2012-5964': 'Stack-based buffer overflow in HTTP GET',
            'CVE-2012-5965': 'Stack-based buffer overflow in unique_service_name',
            'CVE-2025-27484': 'Windows UPnP privilege escalation via memory',
        }
    
    def scan_ssdp_multicast(self, interface: str = '0.0.0.0', timeout: int = 5) -> List[Dict]:
        """
        Scan for UPnP devices via SSDP multicast.
        Returns list of discovered devices.
        """
        print(f"[UPnP Scanner] Scanning for SSDP devices...")
        
        devices = []
        ssdp_request = (
            'M-SEARCH * HTTP/1.1\r\n'
            'HOST: 239.255.255.250:1900\r\n'
            'MAN: "ssdp:discover"\r\n'
            'MX: 3\r\n'
            'ST: ssdp:all\r\n\r\n'
        )
        
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            sock.settimeout(timeout)
            # Note: Binding to 0.0.0.0 is required for SSDP multicast discovery
            # This is a security tool for authorized network scanning only
            # The socket only receives UDP responses and is closed after scan
            sock.bind((interface, 0))
            
            # Send M-SEARCH request
            sock.sendto(ssdp_request.encode(), ('239.255.255.250', 1900))
            
            # Collect responses
            start_time = datetime.now()
            while (datetime.now() - start_time).total_seconds() < timeout:
                try:
                    data, addr = sock.recvfrom(4096)
                    device_info = self._parse_ssdp_response(data.decode('utf-8', errors='ignore'), addr[0])
                    if device_info:
                        devices.append(device_info)
                        self.devices_scanned.append(device_info)
                except socket.timeout:
                    break
                except Exception as e:
                    print(f"[UPnP Scanner] Error receiving response: {e}")
            
            sock.close()
            
        except Exception as e:
            print(f"[UPnP Scanner] Error in SSDP scan: {e}")
        
        print(f"[UPnP Scanner] Discovered {len(devices)} UPnP devices")
        return devices
    
    def _parse_ssdp_response(self, response: str, ip: str) -> Optional[Dict]:
        """Parse SSDP M-SEARCH response."""
        if 'HTTP/1.1 200 OK' not in response and 'HTTP/1.0 200 OK' not in response:
            return None
        
        device = {
            'ip': ip,
            'timestamp': datetime.utcnow().isoformat() + 'Z',
            'headers': {}
        }
        
        # Parse headers
        for line in response.split('\r\n'):
            if ':' in line:
                key, value = line.split(':', 1)
                device['headers'][key.strip().upper()] = value.strip()
        
        # Extract key information
        device['location'] = device['headers'].get('LOCATION', '')
        device['server'] = device['headers'].get('SERVER', '')
        device['usn'] = device['headers'].get('USN', '')
        
        return device
    
    def check_device_vulnerabilities(self, device: Dict) -> List[Dict]:
        """
        Check a discovered device for known vulnerabilities.
        Returns list of vulnerabilities found.
        """
        vulns = []
        
        # Check server version
        server = device.get('server', '')
        if server:
            # Check for vulnerable libupnp versions
            # Note: This is a heuristic check. For production use, consider:
            # 1. Additional validation via device XML descriptors
            # 2. Banner correlation with known device databases
            # 3. Active version fingerprinting if authorized
            for vuln_pattern in self.vulnerable_versions:
                if re.search(vuln_pattern, server, re.IGNORECASE):
                    vulns.append({
                        'device_ip': device['ip'],
                        'vulnerability': 'VULNERABLE_LIBUPNP_VERSION',
                        'severity': 'CRITICAL',
                        'description': f"Vulnerable libupnp version detected: {server}",
                        'confidence': 'MEDIUM',  # Based on banner matching only
                        'cves': [
                            'CVE-2012-5958', 'CVE-2012-5959', 'CVE-2012-5960',
                            'CVE-2012-5961', 'CVE-2012-5962', 'CVE-2012-5963',
                            'CVE-2012-5964', 'CVE-2012-5965'
                        ],
                        'remediation': 'Update libupnp to version 1.6.18 or later',
                        'validation_note': 'Verify version via additional methods before taking action'
                    })
        
        # Check for exposed UPnP on potentially public-facing interface
        if device.get('location'):
            location = device['location']
            # Check if location might be WAN-facing (simplified check)
            if not any(priv in location for priv in ['192.168.', '10.', '172.16.', '127.0.']):
                vulns.append({
                    'device_ip': device['ip'],
                    'vulnerability': 'UPNP_WAN_EXPOSURE',
                    'severity': 'HIGH',
                    'description': 'UPnP service may be exposed on WAN interface',
                    'location': location,
                    'remediation': 'Disable UPnP on WAN interfaces, use firewall to block external access'
                })
        
        # Check for Windows UPnP devices (potential CVE-2025-27484)
        if 'windows' in server.lower() or 'microsoft' in server.lower():
            vulns.append({
                'device_ip': device['ip'],
                'vulnerability': 'WINDOWS_UPNP_MEMORY_RISK',
                'severity': 'HIGH',
                'description': 'Windows UPnP device - potential privilege escalation risk (CVE-2025-27484)',
                'cves': ['CVE-2025-27484'],
                'remediation': 'Apply latest Windows security patches, restrict network access to UPnP service'
            })
        
        # Check for SSDP spoofing susceptibility
        if device.get('usn'):
            vulns.append({
                'device_ip': device['ip'],
                'vulnerability': 'SSDP_SPOOFING_SUSCEPTIBLE',
                'severity': 'MEDIUM',
                'description': 'Device discoverable via SSDP - susceptible to spoofing attacks',
                'attack_vector': 'Evil SSDP - fake device advertisement',
                'remediation': 'Implement SSDP authentication, segment network, monitor for rogue devices'
            })
        
        # Store vulnerabilities
        self.vulnerabilities.extend(vulns)
        
        return vulns
    
    def test_buffer_overflow(self, device: Dict) -> Optional[Dict]:
        """
        Test for buffer overflow vulnerabilities (safe test).
        Sends oversized but non-malicious SSDP requests.
        """
        if not device.get('ip'):
            return None
        
        print(f"[UPnP Scanner] Testing buffer overflow resilience for {device['ip']}")
        
        # Send oversized but safe M-SEARCH request
        oversized_request = (
            'M-SEARCH * HTTP/1.1\r\n'
            'HOST: 239.255.255.250:1900\r\n'
            'MAN: "ssdp:discover"\r\n'
            'MX: 3\r\n'
            f'ST: {"A" * 512}\r\n\r\n'  # Oversized ST header
        )
        
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            sock.settimeout(2)
            sock.sendto(oversized_request.encode(), (device['ip'], 1900))
            
            # Check if device responds (should handle gracefully)
            try:
                data, addr = sock.recvfrom(4096)
                # Device responded - likely handles oversized requests properly
                result = {
                    'test': 'buffer_overflow_resilience',
                    'result': 'PASSED',
                    'note': 'Device handled oversized request without crashing'
                }
            except socket.timeout:
                # No response - could indicate crash or proper rejection
                result = {
                    'test': 'buffer_overflow_resilience',
                    'result': 'UNCERTAIN',
                    'note': 'No response to oversized request - verify device status'
                }
            
            sock.close()
            return result
            
        except Exception as e:
            return {
                'test': 'buffer_overflow_resilience',
                'result': 'ERROR',
                'error': str(e)
            }
    
    def generate_report(self) -> Dict:
        """Generate comprehensive vulnerability report."""
        report = {
            'scan_timestamp': datetime.utcnow().isoformat() + 'Z',
            'devices_scanned': len(self.devices_scanned),
            'vulnerabilities_found': len(self.vulnerabilities),
            'severity_summary': {
                'CRITICAL': 0,
                'HIGH': 0,
                'MEDIUM': 0,
                'LOW': 0
            },
            'devices': self.devices_scanned,
            'vulnerabilities': self.vulnerabilities,
            'cve_database': self.known_cves
        }
        
        # Count by severity
        for vuln in self.vulnerabilities:
            severity = vuln.get('severity', 'UNKNOWN')
            if severity in report['severity_summary']:
                report['severity_summary'][severity] += 1
        
        return report
    
    def save_report(self):
        """Save vulnerability report to file."""
        os.makedirs(self.output_dir, exist_ok=True)
        
        report = self.generate_report()
        output_file = f"{self.output_dir}/upnp_vulnerability_scan.json"
        
        with open(output_file, 'w') as f:
            json.dump(report, f, indent=2)
        
        print(f"\n[UPnP Scanner] Vulnerability report saved to {output_file}")
        print(f"[UPnP Scanner] Devices scanned: {len(self.devices_scanned)}")
        print(f"[UPnP Scanner] Vulnerabilities found: {len(self.vulnerabilities)}")
        
        if self.vulnerabilities:
            print("\n[UPnP Scanner] Severity Summary:")
            for severity, count in report['severity_summary'].items():
                if count > 0:
                    print(f"  {severity}: {count}")


def main():
    """Run UPnP vulnerability scanner."""
    scanner = UPnPVulnerabilityScanner()
    
    # Discover devices
    devices = scanner.scan_ssdp_multicast(timeout=5)
    
    # Check each device for vulnerabilities
    for device in devices:
        print(f"\n[UPnP Scanner] Checking device: {device['ip']}")
        vulns = scanner.check_device_vulnerabilities(device)
        
        if vulns:
            print(f"  Found {len(vulns)} vulnerabilities")
            for vuln in vulns:
                print(f"  - {vuln['vulnerability']} ({vuln['severity']})")
        
        # Test buffer overflow resilience (optional)
        # test_result = scanner.test_buffer_overflow(device)
        # if test_result:
        #     print(f"  Buffer overflow test: {test_result['result']}")
    
    # Save report
    scanner.save_report()


if __name__ == '__main__':
    main()
